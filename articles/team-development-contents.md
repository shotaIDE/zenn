---
title: "チーム開発をうまくやるために技術リードとして取り組んだ内容"
emoji: "🕌"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["ios", "android"]
published: false
---

こんにちは、モバイルエンジニアのころむにーです。

普段、モバイルアプリを通じたユーザーへの価値提供を目指すプロジェクトに、技術リードという立場で参加しています。

本記事では、今入っているプロジェクトで取り組んでいる内容について、紹介してみます。

## はじめに

プロジェクトにおいて、チーム開発で価値提供を継続していくことに技術リードとして取り組みました。

関わるステークホルダーは様々でしたので、さまざまな視点で取り組みを行いました。

- プロダクトオーナー
- デザイナー
- iOS エンジニア、Android エンジニア
- QA
- サポート
- 運用・監視
- バックエンドエンジニア
- Web フロントエンドエンジニア

その他

- アプリのメトリクス可視化
  - 内部品質の定量的な指標の可視化
  - 開発プロセスのメトリクスの可視化
  - 主要な機能のパフォーマンス可視化

## 前提

iOS/Android のモバイルアプリを開発するプロジェクトです。

- iOS/Android それぞれ 5 人程度のエンジニアが関わる規模です

## 1. 価値提供の中身を、技術を踏まえて最適化する

プロダクトにおいて、技術を無視して価値提供を続けていくことはできません。
複雑すぎる技術をプロダクトのいたるところで使うと、価値提供のスピードが遅くなり、最悪の場合、プロダクトの寿命を縮めてしまうこともあります。
一方で、簡単な技術を優先しすぎるあまり UX が下がると、プロダクトの価値を下げることに繋がってしまいます。

このように、技術と価値提供の内容はうまくバランスを取る必要があります。

そこで、プロジェクトにおいて、以下のような取り組みを行いました。

### 1-1. 技術と仕様のバランスを取る

実現が技術的に難しい仕様は、サービスにとっての仕様の重要度と技術的なコストを踏まえて、妥協点を探る必要があります。
技術的に難しい仕様を開発者が人知れず頑張って実装してしまうと、機能開発時のスピードや今後のメンテナンス性の悪化につながります。

例えば、以下のような内容です。

- 親切にエラーメッセージを出そうとすると実装が難しいが、エラーパターンがかなりのレアケースなので簡潔にする

### 1-2. バックエンドとフロントエンドのバランスを取る

仕様の実現の際、バックエンドとフロントエンドのどちらにロジックを寄せるかは、よく検討する必要があります。
実装時の妥当性と、今後の拡張性などもさまざまな要素を踏まえて、バランスを取る必要があります。

例えば、以下のような内容です。

- Web、iOS、Android で共通のロジックは、バックエンドに寄せる
- 既存の API の修正に関して、iOS、Android の古いアプリから呼び出されても問題ないよう後方互換性を保証する
- ユーザー操作にリアルタイムで反応させる機能の実現では、バックエンドへの負荷削減とレスポンス速度を優先しフロントエンドのロジックに寄せる
- 今後バックエンド側が機能拡張された際に、iOS、Android のアプリにおける致命的なバグが起こらないよう、異常系の処理を定義しておく

### 1-3. 外部環境の変化に適応する計画を組み込む

新しい OS バージョンへの対応や、ストアのポリシー変更などは、期限が決まっていることも多いため、早めに対応していくことが重要です。
場合によっては、新機能追加よりも、これらの対応を優先するようにロードマップを並び替えることも必要になってきます。

例えば以下のような内容を対応しました。

- 新しい OS バージョンへの対応
- ストアのポリシー変更への対応
- ライブラリのサポート終了に伴うバージョンアップ

また、モバイル OS は、新しいバージョンがリリースされると OS 自体に新しい機能が追加されます。
それらの機能を活用した新機能をアプリに追加する計画をプロダクトオーナーに提案し、ロードマップに組み込むことも、価値提供の一環として重要です。

## 2. 価値提供のプロセスを、技術を踏まえて最適化する

継続的に価値提供し続けるためには、プロセスも最適化することが重要です。
どんなに魅力的な機能を提供しても、リリースまでの時間が長すぎると、競合のサービスに負けてしまうことがあります。
また、ミスのリスクが高いプロセスになっていてバグが多いと、結果的にユーザーの満足度が下がってしまいます。

そこで、短いサイクルでのリリースに耐えうるプロセスを構築しました。

### 2-1. ブランチ管理の最適化

ブランチ管理は、複数人での開発する上で重要な要素です。
しかし、ブランチ管理は一般的に複雑になりがちで、オペレーションミスや意図しないバグが発生するリスクをはらみます。

そのため、トランクベース開発を導入しました。
トランクベース開発は、リリースのために大きなマージをするなどの間違いや意図しないバグが発生するリスクを極力減らし、安定した価値提供を実現できます。

また、トランクベース開発を実現するために、以下のような取り組みをしています。

- 1、2 日以内で完了するタスク単位に分割
- トランクブランチにおける高頻度の手動リグレッションテスト
- トランクブランチでの 自動リグレッションテスト(E2E テスト)を実行し、失敗した場合はすぐに修正する
- トランクブランチへの PR マージ前に静的解析、単体テストなどをチェックし、パスしていない場合はマージを禁止する

トランクベース開発についてはいくつか記事を書いたことがあるので、こちらも参考にしてみてください。

https://zenn.dev/sun_asterisk/articles/trunk-based-development-strategy

https://zenn.dev/sun_asterisk/articles/trunk-based-development-pros-and-cons

### 2-2. 機能のロールアウト方法の最適化

ユーザーの手元で動作するプログラムを置き換える「デプロイ」と、ユーザーの手元で新機能が発動する「ロールアウト」を分離するという方法があります。
こうすることで、例えば以下のような新機能公開のオペレーションが行えるようになります。

- 新機能をデプロイした後、1 割のユーザーにだけ新機能をロールアウトする
- 新機能に問題があるとわかった場合、新機能のロールアウトを停止し、被害を最小限に抑える

このように、価値提供にはらむリスクへの対応策が増えます。
そのため、プロジェクトではデプロイとロールアウトを分離する方法を導入しています。

:::message
デプロイとロールアウトを分離は、トランクベース開発を導入した際にはほぼ必須になる仕組みです。
:::

このために、以下のような取り組みをしています。

- 設計時点で、ロールアウトの方式を決める
- 必要に応じてフィーチャートグルを導入する

## 3. 開発者のオーナーシップを実装以外の工程にも広げる

変化の早い環境で継続的に価値提供するためには、開発者が設計や実装以外の工程（要件定義、テスト、運用・監視）に対してもオーナーシップを広げていくことが重要と考えます。

プロジェクトでは、以下のような取り組みを行いました。

### 3-1. 開発者自身で基本的仕様がデグレしていないことを確認する

開発者自身で基本的仕様がデグレしていないことを確認することに取り組みました。
開発者が見つければ、より早い工程で修正できるため、プロセス全体で見て効率が良くなります。

そのため、E2E 自動テストを開発者自身で実装しメンテナンスしていくことを取り組みました。
日次で E2E テストを実行し、失敗した場合はすぐに原因究明し、修正するようにしました。

これにより、以下のような成果がありました。

- 操作性が悪くなるというデグレを早期に発見し、修正できた

### 3-2. 開発者自身で運用監視におけるエラーレポートを確認する

開発者自身で運用監視におけるエラーレポートを確認することに取り組みました。
開発者が見つければ、潜在的なコードの問題を発見し、より頑健なコードに繋げることができます。

そのため、エラーレポート（クラッシュやフリーズなど）を定期的に確認し、改善のバックログに起票する取り組みを行うようにしました。

これにより、以下のような効果がありました。

- 潜在的に問題のあるコードの箇所を特定し、修正できた

## 4. プロジェクトのリスクを下げる

継続的な価値提供をするためには、予期しないトラブルなどをできるだけ抑え、価値提供の取り組みにフォーカスできる環境を作ることが重要です。

プロジェクトでは、以下のような取り組みを行いました。

### 4-1. アプリのメトリクスに基づく意思決定

アプリのメトリクスを収集し、データに基づいた意思決定ができると、合理的にリスクを下げることができます。

前提として、プロジェクトで扱うアプリは、プッシュ通知が重要な機能の 1 つでした。
ある時、Android のプッシュ通知に関して、端末でプッシュ通知を表示する仕組みで利用していた SDK のメソッドにおける End of Life(EOL)対応が必要になりました。

この際、サーバーからプッシュ通知を送信した後、Android 端末でどの程度正常に遅延なく表示されているかを収集できる仕組みを作りました。
以下のようにダッシュボードを作り、分析ができるようにしています。

![](/images/team-development-contents/android-push-notification-dashboard.png)

これにより、まず一部ユーザーに変更をデプロイし、その後のユーザーへの展開を検討する際に、データに基づいた意思決定ができるようになりました。

### 4-2. 外部要因で各種ワークフローが動かなくなるリスクをできるだけ下げる

アプリやビルドツールなどでは、外部のライブラリを活用することが多いです。
一方で、これらの外部ライブラリのバージョンアップなどにより、突然動かなくなるなどのリスクがあります。
そのため、外部ライブラリの利用するバージョン自体をバージョン管理に置き、確実に動く状態で維持することが重要です。

プロダクトコードに利用するライブラリは、バージョン自体をバージョン管理に置くことが一般的です。
しかし、ビルドツールなどのライブラリは、バージョン管理に置かれずゆるく扱われることも多いです。

そのため、プロジェクトでは以下のような取り組みを行いました。

- ビルドツールの fastlane に関して、利用する Ruby のバージョンを固定する

https://fastlane.tools/

これにより、以下のようなことができるようになりました

> Ruby のバージョンを更新するメンテナンスを行うタイミングで、CI/CD のワークフローが動かなくなることが分かり、原因調査を行うことができた。

### 4-3. ワークフローのオペレーションミスを排除するように仕組み化する

開発のワークフローでは取り決めがありますが、それを人手で完璧に守るのは難しいです。
そのため、ワークフローのオペレーションミスを排除するように仕組み化することが重要です。

プロジェクトでは、以下のような取り組みを行いました。

> バックログのチケットと PR が紐づいているかを自動でチェックする

これには、Danger を利用しています。

https://danger.systems/ruby/

GitHub のブランチ保護ルールで、Danger によるチェックがパスしない場合はマージを禁止するようにしています。

https://docs.github.com/ja/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule

これにより、以下のようなことができるようになりました

- PR に必ずバックログのチケットが紐づけられるようになり、紐付け漏れが 0 になった

## 5. 内部品質を継続的に改善する

中長期的な期間で継続的に価値提供していくサービスにおいては、コードのメンテナンス性などの内部品質を高く保ち続ける取り組みが必須です。

内部品質が継続的に改善し続けないと、バグが増えるなどの外部品質に悪影響を及ぼし、機能提供のスピードが落ちていくなど、価値提供に悪影響を及ぼします。

そのため、以下のような内部品質を継続的に改善し続けるための取り組みを行いました。

### 5-1. 定量的に測れる内部品質が悪化しないようにするための CI

コードの内部品質が悪化しないようにすることが重要です。
エンジニア同士のコードレビューで指摘していく方法もありますが、CI で自動的にチェックすることで、エンジニアの負担を減らし、コードの品質を保つことができます。

以下のような取り組みを行いました。

- 静的解析による指摘事項が増えないようにする
- デッドコードが増えないようにする
- PR 提出時に、Typo が増えないことを自動チェック

これにより以下のような効果がありました。

- 静的解析による指摘事項が 0 になり、0 で維持することが当たり前になった
- デッドコードが増えないようになり、コードのメンテナンス性が向上した
- 静的解析やデッドコードなどを気にする動きがエンジニア間でみられるようになった

### 5-2. 開発プロセスやコード品質の定性的・定量的な測定と観察

リファクタリングや開発プロセスの改善の取り組みが正しい方向に進んでいるかの自信を持つために、それらの取り組みの効果を定量的・定性的に測定し、観察することが重要です。

以下のような取り組みを行いました。

- エンジニアメンバーによる開発プロセスに関する訂正的なアンケートの実施と集計
- コード品質のメトリクス(単体テストのコードカバレッジ)の定量的な測定と観察

これにより、以下のような効果がありました。

- コード品質が順調に維持・向上しているかを確認できるようになった
- 開発メンバーがコード品質のメトリクス(単体テストのコードカバレッジ)を意識する場面が見られた

## 6. 開発プロセスを効率化する

継続的な価値提供をするためには、開発プロセスを継続的に効率化する取り組みが必要です。

以下のような開発プロセスを効率化する取り組みを行いました。

### 6-1. 開発やテストを効率化するための仕組み

iOS や Android アプリでは、API を通じてデータのやり取りすることが多いです。
その際に、API のリクエストやレスポンスを確認したり、遅延や改ざんなどをしたりすることで、開発やテストに役立つことが多くあります。

そのため、以下のような取り組みを行いました。

- Fiddler や Charles などのプロキシーツールの使い方を簡単にドキュメントにまとめ、開発メンバーや QA が使いやすいようにした
- Web ソケットの通信をプロキシーツールで確認できるようにするため、アプリ内でプロキシー設定ができるようなデバッグ機能を実装

https://www.telerik.com/fiddler

https://www.charlesproxy.com/

実際に、プロキシーツールを使って、以下のようなことができるようになりました。

- ネットワークが遅い状況で再現するバグの調査がしやすくなった
- API 修正において、レスポンスを改ざんすることで、効率よく影響範囲を調査できるようになった

### 6-2. ワークフロー効率化

アプリに利用しているライブラリは、定期的にバージョンアップされています。
これを手動で行うと、手間がかかるだけでなく、対応漏れが発生する可能性もあります。

そのため、dependabot や Renovate などのツールを導入し、ライブラリのバージョンアップの PR が自動で作成されるようにしました。

https://docs.github.com/ja/code-security/dependabot/working-with-dependabot

https://docs.renovatebot.com/

## その他メモ

- スプリント開発用のビルドのデプロイ自動化
- リリース用のビルドのデプロイ半自動化（トランクベース開発を考慮）
- E2E 自動テスト実行時の画面収録を蓄積
- E2E 自動テストにおけるテストケースと確認観点のドキュメントデプロイを自動化
