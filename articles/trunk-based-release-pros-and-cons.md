---
title: "トランクベース開発におけるメリットとデメリット"
emoji: "⛴️"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["トランクベース開発"]
published: false
---

# はじめに

トランクベース開発は、シンプルかつ強力な開発方法です。
上手く運用できれば、開発チームのパフォーマンスを最大限引き出し、爆速の開発を実現できます。

しかし、全ての開発現場で適しているものではありません。

本記事では、私が実際にトランクベース開発を導入し、運用している中で感じたメリットとデメリットを記載してみます。

# 前提

トランクベース開発では、短いサイクルでトランクブランチにマージしていきます。
そのため、開発途中のコードもトランクブランチにマージされていくことになります。

こうした状況で、トランクブランチをリリース可能な状態にするには、フィーチャートグルの導入がほぼ必須です。

マージとデプロイの分離が必須です。

その 1 つの手段としてフィーチャートグルがあります。
本記事では、マージとデプロイの手段としてのフィーチャートグルを導入している前提で解説します。

# メリット

トランクブランチ開発は、生存期間の長いブランチを許容しないことが最大の特徴です。
その点が異なる Git-flow や GitLab-flow、GitHub-flow などのブランチ戦略と比較した、メリット・デメリットを記載します。

## 開発メンバーが実施しなければならないブランチ管理が限りなく簡単になり、開発スピードが爆速になる

- ブランチ管理やコンフリクト対応、マージ対応などを全てのメンバーが行うには、ハードルが高いため
- ブランチ管理にコストを取られ、価値提供にコストを使えなくなるのを防ぎたいため
- コンフリクトが少なくなる

長大なブランチ管理のための手順書を覚える必要がない。

## 1 本のブランチ上で開発、テスト、自動チェック(CI)を集中することで、これらのコストパフォーマンスを最大化できる

- CI の価値を最大化するため
- 定期的な自動・手動リグレッションテストのコストを最小にしつつ、価値を最大化するため
- 開発者・QA が同じブランチを触る・検証する
- トランクブランチが壊れた場合にすぐに気づきやすく、復元時間を最短にできる。

## リリースが大規模イベントではなくなり、日々の細かいタスクで分割される

1 つ 1 つの PR をマージする際に修正がリリースされた際のことを考えます。
そのため、リリースの直前に大きなコストをかけてリスクを考える必要がなくなります。

前工程の段階でリスクをつぶしておけるので、シフトレフトの原則にのっとることができます。

# デメリット

## デプロイとロールアウトを分離する必要があるため、開発の複雑性が増し、学習コストが高くなる

デプロイとロールアウトの分離を実施する場合、以下のように開発、テスト、運用などのプロセスがそれぞれ複雑化します。

- コード上でフィーチャートグルを管理し、ON/OFF 時の挙動の分岐を管理する
- テスト時にフィーチャートグル ON/OFF 両方の状態でテストを行う
- サーバー側でフィーチャートグルが動的に切り替える運用が想定される場合は、テスト時に ON と OFF 状態を行き来するパターンの挙動を確認する
- フィーチャートグルを切り替える運用が発生する
- フィーチャートグルを削除するメンテナンスを行う
- 監視やログの設計が複雑化する

これにより、プロセスの工数が少しずつ増え、メンバー間のコミュニケーションコストも少しずつ増えてきます。

具体的には以下のようなコミュニケーションが発生します。

「機能 A はフィーチャートグルを使って実装しましょう。フィーチャートグル OFF の場合は、機能 A が表示されないようにしてください。」

「今回のリリースには機能 B が含まれます。機能 B はフィーチャートグルを使って実装しているため、リリース時にフィーチャートグルを ON にする必要があります。」

さらに、デプロイとロールアウトが分離されているため、プロダクトオーナーやビジネスサイドのメンバーにも説明が必要になってきます。

例えば、以下のようなコミュニケーションが必要になってきます。

「機能 A は来週月曜日から 2 週間かけて一般ユーザーに徐々に開放されていきます。」

「機能 B は来週月曜日に全ユーザーへ公開されます。もし、監視で問題が発生した場合は、すぐに機能 B を無効化します。」

こうしたコミュニケーションは、プロダクトの外部への発信やユーザーへのサポートなどに必要です。

## 品質基準やリリース計画とは関係なくまぜこぜに修正が取り込まれていく

包括的な自動テストや高サイクルのリグレッションテストを回していても、バグは発生するものです。
そのように、十分にテストされていないコードやバグを含むコードがトランクブランチにマージされる状態は発生します。

これらが発生している状態だと、リリースのタイミングでバグが流出してしまうリスクが高まります。

そのように、テストを充分に行い品質を担保してから修正を取り込みたい場合には、トランクベース開発は向いていない可能性があります。

また、バグ修正のロールアウトをコントロールすることは難しいため、リリースタイミングを調整したい場合とは相性が悪いという問題もあります。

フィーチャートグルなどをでバグが修正されていない状態と修正されている状態を切り替えることは一般的に難しい場合が多いです。
これは、バグ修正は一般的に複雑なコード修正を伴うため、フィーチャートグルで管理するコストが高くなるためです。
また、再現性の問題で、フィーチャートグルの切り替えに伴う動作確認が難しい場合もあります。

トランクベース開発では、バグ対応は、順次リリースに入れていくということをプロダクトオーナーと握っておくのが良いでしょう。

一方で、バグ修正がユーザーの手元で適用されるタイミングを完全にコントロールしたいという場合には、トランクベース開発は向いていない可能性があります。

# その他

ただ、そもそも実装したのにリリースに入れない、ということは、長い時間マージされないブランチやコミットが存在することになります。
これは管理やマージ時のリスクを考えるとそもそも避けたいことです。

### そもそもなぜ長い時間マージされないブランチやコミットが存在すると、リスクが高まるのか

コード修正は、「元々のコード状態」を踏まえた上で修正を加える、という営みです。

開発は日々進んでいくため、マージする対象のコードは日々変わっていきます。
つまり「元々のコード状態」が日々変わっていくため、時間が経つにつれ修正の加え方を再検討する必要が生じてきます。

そのため、元々のコード状態が変わってしまうと、修正を加える際に元々のコード状態を踏まえた上で修正を加える、ということが難しくなります。

Git は親コミットに対して差分を適用していく構造になっている。
そのため、コミット 1→ コミット 2→ コミット 3 という順番で並んでいた時に、コミット 1→ コミット 3 という順番で並び替えるためにはチェリーピックが必要となる。

チェリーピックはマージと異なり、コミット 3 の差分をコミット 1 の子として新しく作り直すという作業になる。
そのため、元々のコミット 3 とは別のハッシュ値を持つコミット 3 ができる。

# メリットとデメリットの比較

Git-flow などのブランチ戦略に比べて、トランクベース開発によるリリース戦略は以下のような特徴があります。

開発中の機能もフィーチャーフラグなどを利用してトランクブランチにマージされていきます。
これにより、全ての開発メンバーがビルドし修正するコードに早期統合されるため、設計の破綻やコードの不都合を早期に発見しやすくなります。

全ての開発メンバーで 1 つのコードを共有し、全ての QA メンバーで 1 つのアプリを検証することになります。

リリース前のタイミングで統合するよりも、早いタイミングで統合していくことで、統合の痛みを分散させていくという取り組みとも言えます。

このように考えることで、リリースの頻度を高めることができます。

コード中の分岐の扱いを間違えるというミスよりもブランチ管理を間違えるというミスの方が体感としては発生しやすいです。

これらを踏まえ、将来的に目指す方向性と合っていると考えて、採用し運用中です。

ブランチ管理の方が、ブランチ管理のためのコストが高いです。

# 最後に

本記事では、私が実際にトランクベース開発を導入し、運用している中で感じたメリットとデメリットを記載してみました。

トランクベース開発を導入する際には、メリットとデメリットを踏まえて、適切な運用方法を検討してみてください。
