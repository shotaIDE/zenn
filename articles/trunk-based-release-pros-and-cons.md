---
title: "トランクベース開発におけるメリットとデメリット"
emoji: "⛴️"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["トランクベース開発"]
published: false
---

# 前提

トランクベース開発では、短いサイクルでトランクブランチにマージしていきます。
そのため、開発途中のコードもトランクブランチにマージされていくことになります。

こうした状況で、トランクブランチをリリース可能な状態にするには、フィーチャートグルの導入がほぼ必須です。

マージとデプロイの分離が必須です。

その 1 つの手段としてフィーチャートグルがあります。
本記事では、マージとデプロイの手段としてのフィーチャートグルを導入している前提で解説します。

# メリット

トランクブランチ開発は、生存期間の長いブランチを許容しないことが最大の特徴です。
その点が異なる Git-flow や GitLab-flow、GitHub-flow などのブランチ戦略と比較した、メリット・デメリットを記載します。

## 開発メンバーが実施しなければならないブランチ管理が限りなく簡単になる

- ブランチ管理やコンフリクト対応、マージ対応などを全てのメンバーが行うには、ハードルが高いため
- ブランチ管理にコストを取られ、価値提供にコストを使えなくなるのを防ぎたいため
- コンフリクトが少なくなる

長大なブランチ管理のための手順書を覚える必要がない。

## 副次的な効果として、フィーチャーフラグによりリリースの柔軟性やベータテストの柔軟性が高まる

ビジネス的な要求によりリリースを一旦遅らせたいなどの場合、フィーチャートグルを ON 固定にするタイミングを変えるだけです。
そのため、開発側としては、特にコストやリスクなく変えやすいです。

- リモートで管理することにより、切り戻しの範囲を柔軟に設定でき、切り戻しの所要時間を最小化できる
- 範囲や段階を柔軟に設定したカナリアリリースができる
- アプリ内で管理することにより、アーリーアクセス機能としてのリリースができる
  - ユーザーによるフィードバックを得ることができる

## 1 本のブランチ上で開発、テスト、自動チェック(CI)を集中することで、これらのコストパフォーマンスを最大化できる

- CI の価値を最大化するため
- 定期的な自動・手動リグレッションテストのコストを最小にしつつ、価値を最大化するため
- 開発者・QA が同じブランチを触る・検証する
- トランクブランチが壊れた場合にすぐに気づきやすく、復元時間を最短にできる。

# デメリット

## 開発メンバーにとってのメリットが大きいため、力関係によっては導入しにくい

## マージとデプロイを分離する必要があるため、開発プロセス全体で少しずつ複雑性が増す

設計中に、開発中の機能がコード差分的にはリリースに含まれていても、発動しないようにする必要があります。

- 一時的に分岐が発生することにより、コードの複雑さが増す
- サイレントリリースすることにより、デプロイや監視のオペレーションパターンが増える
- フィーチャーフラグを外すことを将来行う必要がある

## フィーチャーフラグはブランチ管理よりも理解されていないことが多いため、プロジェクトメンバーの学習コストが発生しやすい

サイレントリリースされています。
しかし、マージとデプロイは分離されているので、「これは次でリリースされる予定ですが、まだ一般ユーザーには公開されない機能です」というコミュニケーションが必要です。

「フィーチャートグルを利用して開発しているので、テスト時はフィーチャートグルを ON にしてください」というコミュニケーションが必要です。

- プロダクトオーナー、QA など関係者すべてに周知し、キャッチアップしてもらう必要がある

## 良くも悪くも、受け入れ基準やリリース対象などとは関係なくまぜこぜに修正が取り込まれていく

### 細かいバグ修正や改善に関して、開発時期と独立してリリースに取り込みたい内容を取捨選択するのが難しくなる

トランクブランチに全てのコミットをマージしていくため、フィーチャーフラグなどで管理しているような機能は問題ないです。
ただ、細かいバグ対応なども全てフィーチャーフラグなどで管理することは現実的でないです。

リリースの際にはトランクブランチの特定の時点でリリースビルドを行うため、こうした細かいバグ対応を入れないということが難しくなります。

ただ、そもそも実装したのにリリースに入れない、ということは、長い時間マージされないブランチやコミットが存在することになります。
これは管理やマージ時のリスクを考えるとそもそも避けたいことです。

そのため、細かいバグ対応は、順次リリースに入れていくということをプロダクトオーナーと握っておくのが良いでしょう。

「次のリリースにはどのバグ修正を含めますか？」というコミュニケーションではなく、「次のリリースにはこれらのバグ修正が含まれる予定です」というコミュニケーションになってきます。

### そもそもなぜ長い時間マージされないブランチやコミットが存在すると、リスクが高まるのか

コード修正は、「元々のコード状態」を踏まえた上で修正を加える、という営みです。

開発は日々進んでいくため、マージする対象のコードは日々変わっていきます。
つまり「元々のコード状態」が日々変わっていくため、時間が経つにつれ修正の加え方を再検討する必要が生じてきます。

そのため、元々のコード状態が変わってしまうと、修正を加える際に元々のコード状態を踏まえた上で修正を加える、ということが難しくなります。

Git は親コミットに対して差分を適用していく構造になっている。
そのため、コミット 1→ コミット 2→ コミット 3 という順番で並んでいた時に、コミット 1→ コミット 3 という順番で並び替えるためにはチェリーピックが必要となる。

チェリーピックはマージと異なり、コミット 3 の差分をコミット 1 の子として新しく作り直すという作業になる。
そのため、元々のコミット 3 とは別のハッシュ値を持つコミット 3 ができる。

# メリットとデメリットの比較

Git-flow などのブランチ戦略に比べて、トランクベース開発によるリリース戦略は以下のような特徴があります。

開発中の機能もフィーチャーフラグなどを利用してトランクブランチにマージされていきます。
これにより、全ての開発メンバーがビルドし修正するコードに早期統合されるため、設計の破綻やコードの不都合を早期に発見しやすくなります。

全ての開発メンバーで 1 つのコードを共有し、全ての QA メンバーで 1 つのアプリを検証することになります。

リリース前のタイミングで統合するよりも、早いタイミングで統合していくことで、統合の痛みを分散させていくという取り組みとも言えます。

このように考えることで、リリースの頻度を高めることができます。

コード中の分岐の扱いを間違えるというミスよりもブランチ管理を間違えるというミスの方が体感としては発生しやすいです。

これらを踏まえ、将来的に目指す方向性と合っていると考えて、採用し運用中です。

ブランチ管理の方が、ブランチ管理のためのコストが高いです。
