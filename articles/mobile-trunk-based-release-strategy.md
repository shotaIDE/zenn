---
title: "「ブランチ複雑化」を解消！トランクベース開発でシンプル＆効率的に"
emoji: "⛴️"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["ios", "android"]
published: false
---

# はじめに

開発を進める中で Git のブランチ戦略を効果的に設計することは欠かせないものです。

今まで Git-flow を含むいくつかのブランチ管理を試してきました。

しかし、ブランチを多く活用すればするほど、開発者自身が気をつけて行うべき活動が増え、事故るリスクが高まります。
また、仕組みにより事故がなくなるようにする際にも、仕組みを作ること自体のコストがかかります。

できるだけシンプルで効果的なブランチ戦略を模索していく中で、**トランクベース開発**にたどり着きました。

https://cloud.google.com/architecture/devops/devops-tech-trunk-based-development?hl=ja

トランクベース開発は、複雑なブランチ戦略を全く取らず、トランクブランチというメインのブランチ 1 つに対してのみエンジニア全員が修正していく開発手法です。

トランクベース開発はシンプルな戦略ではあるのですが、**リリースの際の開発フローについて、プロジェクトに応じて最適な手法を選択したりカスタマイズする必要があります**。

この際に、トランクベース開発で解決したい開発上の課題をよく理解をした上で、プロジェクトの業務フローとの兼ね合いでやり方を調整したり、業務フロー自体を調整する必要があります。

本記事では、私が解釈している「トランクベース開発で解決したいこと」と、現状実践している「トランクベース開発のやり方」についてまとめた記事となります。

# 私のトランクベース開発の解釈

## トランクベース開発で解決したい開発上の課題

一般的によく使われる Git のブランチ機能を多用する開発戦略では、以下のような状態が発生しやすいです。

- 大規模または長期にわたるコード修正を特定のエンジニアだけで閉じて行う
- 修正したコードを一時的にマージしない期間を設ける

これらは、**安全な開発を脅かしたり開発スピードを下げたりする要素となる**ため、トランクベース開発ではこれらを禁止した上で開発フローを再構築します。

### 大規模または長期にわたるコード修正を特定のエンジニアだけで閉じて行う

大規模または長期にわたるコード修正は**認知の負荷やマージの難易度が上がり、それに伴うリスクが高まります**。

- 実装者自身の動作確認が十分に行えないことが多い
- コードレビューが十分に行えないことが多い
- マージ時にコンフリクトが発生し、コンフリクト解消ミスを起こしやすい
- バグ発生時の原因特定が難しい
- 特定のエンジニアだけの知見しか反映されず、他のエンジニアの知見が活かされにくい

![長期、大規模な修正を特定のエンジニアだけで行うのは悪い](/images/mobile-trunk-based-release-strategy/merge-large-changes.png)

以下のような**リリースブランチを作り最後にトランクブランチへマージするという営み**も同様のリスクがあります。

- 開発ブランチからリリースブランチを分岐させ、受け入れ試験で発生したバグ修正をそこに適用し、最後に開発ブランチへマージする
  - このような戦略は、開発ブランチを触っているエンジニアとリリースブランチを触っているエンジニアが異なるため、コンフリクトが発生しやすい

![リリースブランチを作り、最後にマージする](/images/mobile-trunk-based-release-strategy/merge-release-branch.png)

Git-flow などの一般的なブランチ戦略では、よくみられるものです。

### 修正したコードを一時的にマージしない期間を設ける

開発者の手元でコード修正が滞留し、コードレビューやデプロイ、テストなど**各種の開発プロセスが停滞してしまいます**。

一時的にマージしない状況としては、以下のケースが一般的によくあります。

- リリースのためのテストなどを行っている際に、機能開発やリファクタリングなどのコード修正がリリースされるコードに混ざることを防ぐために、一時的にマージをしないようにする

# トランクベース開発の実践方法

## 全体像

小さな修正を頻繁に行い全員が見えるところに公開していきつつ、最終的にトランクブランチにマージするリリースブランチを作らないようにします。

![小さな修正をこまめにマージする](/images/mobile-trunk-based-release-strategy/trunk-base.png)

以下、普段の開発とリリースフロー（定期リリースと hotfix リリース）に焦点を当てて解説していきます。

## 普段の開発

![普段の開発](/images/mobile-trunk-based-release-strategy/development-flow.png)

エンジニアは、**機能開発やバグ修正などのバックログにおけるチケット種別や、ターゲットのリリースバージョンに関わらず、全ての修正をトランクブランチにマージ**します。

PR マージ時に Squash マージを採用しているため、最終的には **PR が 1 つマージされるとトランクブランチに 1 つコミットが生成される**ことになります。

## 定期リリース

定期リリースの際には以下のようなフローをたどります。

```mermaid
flowchart TD
    A[トランクブランチの最新コミットからリリースブランチ作成] --> B[リリースブランチ上でアプリ作成し、テスト]
    B --> C{修正必須バグが見つかった？}
    C -->|Yes| D[トランクブランチに修正を適用]
    D --> E[リリースブランチにも修正を適用]
    E --> B
    C -->|No| F[リリース]
```

1. 基本的にはトランクブランチの最新コミットからリリースブランチを分岐させ、初回ビルドする。
2. ビルドされたアプリに対しテストを行う。
3. リリースまでに修正必須の重大度のバグが見つかれば、バグ修正をトランクブランチに適用し、リリースブランチにも適用する。
4. リリースブランチで追加ビルドを行い、再テストする。
5. 2-4 を修正必須のバグがなくなるまで繰り返し、最後のビルドをリリースする。

リリースした後、**リリースブランチはトランクブランチにはマージしません**。

以下、詳細に解説していきます。

### 初回ビルド

![1回目のブランチ戦略・弾くコミットがない場合](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_01.png)

基本的には**トランクブランチの最新コミットからリリースブランチを分岐**させます。
分岐させたブランチ上で初回ビルドを行います。

例外としては、以下のような理由により**次のリリースに含みたくない修正がトランクブランチ上に適用されている**場合、それを含まない形でリリースブランチを切ることがあります。

- リリース時のシステム全体へ与えるリスクが高く、その対策ができていない
- デグレを引き起こすことが明確に分かっている
- 後のリリースで提供したい機能である

![1回目のブランチ戦略・弾くコミットがある場合](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_02.png)

:::message
基本的には上記のように特定のコミットだけリリースに含めないということは、後述するようにリリース戦略が複雑になるため避けるべきです。
これを避けるための手段として、開発の計画段階でシステム全体へのリスクやリリース単位を検討しておき、必要に応じてフィーチャートグル（リリーストグルや Ops トグル）を導入する方法があります。
:::

このように 1 回目のビルドは、特に理由がなければトランクブランチの内容を最新まで全て含めるので、**包括的なかき集め**フェーズと捉えることができます。

### 2 回目以降のビルド

![2回目以降のビルドのブランチ戦略](/images/mobile-trunk-based-release-strategy/trunk-based-regular-release_03.png)

ビルドされたアプリでテストを行い、バグが見つかった場合には**トランクブランチに修正を適用**します。

その後、トランクブランチ上の修正を**リリースブランチにチェリーピックにより適用**します。

:::message
チェリーピックとは、修正内容を別のブランチに対して再適用する作業です。通常は Git の機能により機械的に行えます。
:::

つまり、**リリースブランチ上でテストしている一方で、バグ修正時にはエンジニアはまずトランクブランチで調査と修正をしています**。

テストするブランチとコードを調査・修正するブランチが一致していないのは一見奇妙に思われますが、以下のような考えに基づいています。

- **リリースブランチとトランクブランチは大きく乖離していない前提**なので、バグの再現性やバグ修正のベースとなるコードとして同一視して実用上問題ない
- リリースブランチを担当するエンジニア以外は複雑なブランチ管理をすることなく、バグ修正の内容だけに集中してほしい

トランクブランチとリリースブランチの乖離が大きいと上記の戦略は破綻するため、以下の図に示すような乖離部分が大きくならないよう開発フローや品質を最適化していく必要があります。

![乖離が大きくなってはいけない](/images/mobile-trunk-based-release-strategy/diff-trunk-and-release.png)

:::message
バグ修正を適用した時点のトランクブランチのコミットで 2 回目以降のビルドを行うという選択肢もあります。
しかし、この方法ではトランクブランチにリリースのバグ対応以外の修正が含まれてしまう可能性があり、追加でテストすべき範囲が広がってしまうため採用していません。
:::

以上をまとめると、2 回目以降のビルドは前回のビルドから取り込まれていないコミットを全て精査し、現在ターゲットとしているリリースに必ず含めたいもののみをチェリーピックしています。
必要なもの以外は取り込まないので、**排他的なかき集め**フェーズと捉えることができます。

:::details そのほかの記述

- トランクブランチ上の開発を止めたくない
- リリースブランチは、トランクブランチにはマージしない

トランクブランチが正史であり、トランクブランチに修正します。
その上で、リリース時には、正史の特定の時点を切り出したものとなります。
ところが、特定の時点を切り出すとバグが発生しているという状況の場合、正史の一部分を継ぎ足すことで完成された歴史を作ります。

QA メンバーもトランクブランチ上でビルドされたアプリを使ってテストを行います。

この上で、トランクブランチの特定の時点で切り出してリリースするために必要なコミットをチェリーピックによりかき集めたものとします。

また、総合テストでバグがあまり見つからないことを前提としています。
バグが見つかりすぎると、リリースブランチがトランクブランチと乖離しすぎるため、トランクブランチで修正するのは難しくなってくるためです。

リリースブランチにマージしていくというスタイルは、GitLab-flow に含まれる戦略です。
ただ、フィーチャーブランチを許容していないという点で GitLab-flow とは異なります。

トランクベース開発は息の長いブランチを許容していません。
この息の長いブランチの禁則は、ブランチの分岐元と分岐先が独自にコミットを積み重ねていった結果、安全に統合することが難しくなるためです。
ここでリリースブランチが息の長いブランチになっていますが、リリースブランチはリリース直前に少しチェリーピックが発生するだけです。
そのため、安全に統合できると考え、現状許容しています。

:::

## hotfix リリース

hotfix リリースの際には以下のようなフローをたどります。

```mermaid
flowchart TD
    A[前回のリリースブランチからリリースブランチ作成] --> B[トランクブランチに修正を適用]
    B --> C[リリースブランチにも修正を適用]
    C --> D{修正必須バグが見つかった？}
    D -->|Yes| B
    D -->|No| E[リリース]
```

1. 前回のリリースブランチからリリースブランチ作成する。
2. バグ修正をトランクブランチに適用し、リリースブランチにも適用する。
3. リリースブランチでビルドを行い、テストする。
4. 2-3 を修正必須のバグがなくなるまで繰り返し、最後のビルドをリリースする。

定期リリースと同様に、リリースした後**リリースブランチはトランクブランチにはマージしません**。

ブランチの図で示すと以下のようになります。

![hotfixのブランチ戦略](/images/mobile-trunk-based-release-strategy/trunk-based-hotfix-release.png)

定期リリースの 2 回目以降のビルドと同様に、**排他的なかき集め**フェーズと捉えることができます。

## 次の定期リリースのビルドを開始する

リリースが完了し、次の定期リリースのビルドを開始したい場合は、再度**トランクブランチの最新コミットからリリースブランチを作成**します。

![](/images/mobile-trunk-based-release-strategy/next-release.png)

前回のリリースブランチ(v1.0 リリースブランチ)は、利用しません。

# 最後に

k
